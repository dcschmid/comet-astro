---
import { cn } from '../utils/cn';

export interface TooltipProps {
  content: string;
  variant?:
    | 'default'
    | 'dark'
    | 'light'
    | 'info'
    | 'success'
    | 'warning'
    | 'error';
  size?: 'sm' | 'md' | 'lg';
  position?:
    | 'top'
    | 'bottom'
    | 'left'
    | 'right'
    | 'top-start'
    | 'top-end'
    | 'bottom-start'
    | 'bottom-end';
  trigger?: 'hover' | 'focus' | 'click' | 'manual';
  delay?: number;
  hideDelay?: number;
  disabled?: boolean;
  allowHTML?: boolean;
  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
}

const {
  content,
  variant = 'default',
  size = 'md',
  position = 'top',
  trigger = 'hover',
  delay = 0,
  hideDelay = 0,
  disabled = false,
  allowHTML = false,
  maxWidth = 'xs',
  className = '',
} = Astro.props as TooltipProps;

// WCAG AAA compliant colors with 9:1 contrast ratios
const variantStyles = {
  default:
    'bg-slate-950 text-slate-50 border-slate-700 dark:bg-slate-50 dark:text-slate-950 dark:border-slate-300',
  dark: 'bg-slate-950 text-slate-50 border-slate-700',
  light: 'bg-slate-50 text-slate-950 border-slate-300',
  info: 'bg-blue-950 text-blue-50 border-blue-800 dark:bg-blue-50 dark:text-blue-950 dark:border-blue-200',
  success:
    'bg-emerald-950 text-emerald-50 border-emerald-800 dark:bg-emerald-50 dark:text-emerald-950 dark:border-emerald-200',
  warning:
    'bg-amber-950 text-amber-50 border-amber-800 dark:bg-amber-50 dark:text-amber-950 dark:border-amber-200',
  error:
    'bg-red-950 text-red-50 border-red-800 dark:bg-red-50 dark:text-red-950 dark:border-red-200',
};

const sizeStyles = {
  sm: 'px-2 py-1 text-xs',
  md: 'px-3 py-2 text-sm',
  lg: 'px-4 py-3 text-base',
};

const maxWidthStyles = {
  xs: 'max-w-xs',
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl',
};

const positionClasses = {
  top: 'bottom-full left-1/2 -translate-x-1/2 mb-2',
  bottom: 'top-full left-1/2 -translate-x-1/2 mt-2',
  left: 'right-full top-1/2 -translate-y-1/2 mr-2',
  right: 'left-full top-1/2 -translate-y-1/2 ml-2',
  'top-start': 'bottom-full left-0 mb-2',
  'top-end': 'bottom-full right-0 mb-2',
  'bottom-start': 'top-full left-0 mt-2',
  'bottom-end': 'top-full right-0 mt-2',
};

const arrowColors = {
  default: 'border-t-slate-950 dark:border-t-slate-50',
  dark: 'border-t-slate-950',
  light: 'border-t-slate-50',
  info: 'border-t-blue-950 dark:border-t-blue-50',
  success: 'border-t-emerald-950 dark:border-t-emerald-50',
  warning: 'border-t-amber-950 dark:border-t-amber-50',
  error: 'border-t-red-950 dark:border-t-red-50',
};

const getArrowClasses = (pos: string, variant: string) => {
  const baseArrowColor = arrowColors[variant as keyof typeof arrowColors];

  switch (pos) {
    case 'top':
    case 'top-start':
    case 'top-end':
      return `top-full ${pos === 'top' ? 'left-1/2 -translate-x-1/2' : pos === 'top-start' ? 'left-3' : 'right-3'} ${baseArrowColor.replace('border-t-', 'border-t-')} border-x-transparent border-b-transparent`;
    case 'bottom':
    case 'bottom-start':
    case 'bottom-end':
      return `bottom-full ${pos === 'bottom' ? 'left-1/2 -translate-x-1/2' : pos === 'bottom-start' ? 'left-3' : 'right-3'} ${baseArrowColor.replace('border-t-', 'border-b-')} border-x-transparent border-t-transparent`;
    case 'left':
      return `left-full top-1/2 -translate-y-1/2 ${baseArrowColor.replace('border-t-', 'border-l-')} border-y-transparent border-r-transparent`;
    case 'right':
      return `right-full top-1/2 -translate-y-1/2 ${baseArrowColor.replace('border-t-', 'border-r-')} border-y-transparent border-l-transparent`;
    default:
      return '';
  }
};

const tooltipId = `tooltip-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  class={cn('relative inline-block', !disabled && 'group', className)}
  data-tooltip-root
  data-trigger={trigger}
  data-delay={delay}
  data-hide-delay={hideDelay}
  data-disabled={disabled}
>
  <slot />

  {
    !disabled && (
      <div
        id={tooltipId}
        class={cn(
          'absolute z-50 rounded-lg border shadow-lg',
          'transition-all duration-200 ease-in-out',
          'motion-reduce:transition-none',
          'opacity-0 invisible pointer-events-none',
          'whitespace-nowrap',
          variantStyles[variant],
          sizeStyles[size],
          maxWidthStyles[maxWidth],
          positionClasses[position],
          trigger === 'hover' && 'group-hover:visible group-hover:opacity-100',
          trigger === 'focus' &&
            'group-focus-within:visible group-focus-within:opacity-100',
          (trigger === 'hover' || trigger === 'focus') &&
            'group-focus-visible:visible group-focus-visible:opacity-100'
        )}
        role="tooltip"
        aria-hidden="true"
        data-tooltip
      >
        {allowHTML ? <Fragment set:html={content} /> : content}

        {/* Arrow */}
        <div
          class={cn('absolute border-4', getArrowClasses(position, variant))}
          aria-hidden="true"
        />
      </div>
    )
  }
</div>

<script is:inline>
  (function () {
    const roots = Array.from(document.querySelectorAll('[data-tooltip-root]'));
    if (!roots.length) return;

    roots.forEach((root) => {
      if (!(root instanceof HTMLElement)) return;

      const tooltip = root.querySelector('[data-tooltip]');
      if (!(tooltip instanceof HTMLElement)) return;

      const trigger = root.getAttribute('data-trigger') || 'hover';
      const delay = Number.parseInt(root.getAttribute('data-delay') || '0', 10);
      const hideDelay = Number.parseInt(
        root.getAttribute('data-hide-delay') || '0',
        10
      );
      const disabled = root.getAttribute('data-disabled') === 'true';

      if (disabled) return;

      // Find the target element
      const selector = [
        'a[href]',
        'button',
        'input',
        'textarea',
        'select',
        '[tabindex]:not([tabindex="-1"])',
        '[role="button"]',
        '[role="link"]',
      ].join(',');

      const focusable = root.querySelector(selector);
      const target =
        focusable instanceof HTMLElement
          ? focusable
          : root.firstElementChild instanceof HTMLElement
            ? root.firstElementChild
            : null;

      if (!target) return;

      let showTimeout;
      let hideTimeout;
      let isVisible = false;

      // Enhanced show function with accessibility
      const showTooltip = () => {
        clearTimeout(hideTimeout);

        if (isVisible) return;

        showTimeout = setTimeout(() => {
          tooltip.classList.remove('invisible', 'opacity-0');
          tooltip.classList.add('opacity-100');
          tooltip.setAttribute('aria-hidden', 'false');
          isVisible = true;

          // Announce to screen readers for important tooltips
          if (tooltip.getAttribute('role') === 'tooltip') {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = tooltip.textContent || '';
            document.body.appendChild(announcement);

            setTimeout(() => {
              if (announcement.parentNode) {
                announcement.remove();
              }
            }, 1000);
          }
        }, delay);
      };

      // Enhanced hide function
      const hideTooltip = () => {
        clearTimeout(showTimeout);

        if (!isVisible) return;

        hideTimeout = setTimeout(() => {
          tooltip.classList.add('invisible', 'opacity-0');
          tooltip.classList.remove('opacity-100');
          tooltip.setAttribute('aria-hidden', 'true');
          isVisible = false;
        }, hideDelay);
      };

      // Set up ARIA relationship
      if (!target.getAttribute('aria-describedby')) {
        target.setAttribute('aria-describedby', tooltip.id);
      }

      // Keyboard navigation
      const handleKeyDown = (event) => {
        if (event.key === 'Escape' && isVisible) {
          event.preventDefault();
          hideTooltip();
          target.focus();
        }
      };

      // Event listeners based on trigger type
      if (trigger === 'hover' || trigger === 'focus') {
        // Hover events
        if (trigger === 'hover') {
          target.addEventListener('mouseenter', showTooltip);
          target.addEventListener('mouseleave', hideTooltip);
          tooltip.addEventListener('mouseenter', showTooltip);
          tooltip.addEventListener('mouseleave', hideTooltip);
        }

        // Focus events
        if (trigger === 'focus') {
          target.addEventListener('focus', showTooltip);
          target.addEventListener('blur', hideTooltip);
        }

        // Always support keyboard for accessibility
        target.addEventListener('keydown', handleKeyDown);
      } else if (trigger === 'click') {
        target.addEventListener('click', (event) => {
          event.preventDefault();
          if (isVisible) {
            hideTooltip();
          } else {
            showTooltip();
          }
        });

        target.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            if (isVisible) {
              hideTooltip();
            } else {
              showTooltip();
            }
          } else if (event.key === 'Escape' && isVisible) {
            event.preventDefault();
            hideTooltip();
            target.focus();
          }
        });

        // Close on click outside
        document.addEventListener('click', (event) => {
          if (!root.contains(event.target) && isVisible) {
            hideTooltip();
          }
        });
      }

      // Responsive positioning
      const updatePosition = () => {
        if (!isVisible) return;

        const tooltipRect = tooltip.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Simple collision detection
        if (tooltipRect.right > viewportWidth) {
          tooltip.style.transform = 'translateX(-100%)';
        }
        if (tooltipRect.bottom > viewportHeight) {
          tooltip.style.transform = 'translateY(-100%)';
        }
      };

      window.addEventListener('resize', updatePosition);
      window.addEventListener('scroll', updatePosition);
    });

    // Screen reader only utility class
    if (!document.querySelector('.sr-only-styles')) {
      const style = document.createElement('style');
      style.className = 'sr-only-styles';
      style.textContent = `
        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border: 0;
        }
      `;
      document.head.appendChild(style);
    }

    // Reduced motion support
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      const style = document.createElement('style');
      style.textContent = `
        [data-tooltip] {
          transition: none !important;
        }
      `;
      document.head.appendChild(style);
    }
  })();
</script>

<style>
  [data-tooltip] {
    word-wrap: break-word;
    hyphens: auto;
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    [data-tooltip] {
      border-width: 2px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    [data-tooltip] {
      transition: none !important;
    }
  }

  /* Focus improvements for high contrast */
  @media (forced-colors: active) {
    [data-tooltip] {
      border: 2px solid ButtonText;
      background: ButtonFace;
      color: ButtonText;
    }
  }

  /* Responsive text wrapping */
  @media (max-width: 640px) {
    [data-tooltip] {
      max-width: calc(100vw - 2rem);
      white-space: normal;
    }
  }
</style>
