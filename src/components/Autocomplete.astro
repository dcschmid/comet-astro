---
/**
 * Autocomplete - searchable input with suggestion list
 */
interface Option {
  value: string;
  label: string;
  description?: string;
  keywords?: string[];
}

interface Props {
  options: Option[];
  placeholder?: string;
  label?: string;
  ariaLabel?: string;
  emptyStateText?: string;
  maxVisibleOptions?: number;
  className?: string;
  inputName?: string;
}

const {
  options = [],
  placeholder = 'Search…',
  label,
  ariaLabel,
  emptyStateText = 'No results found.',
  maxVisibleOptions = 8,
  className = '',
  inputName,
} = Astro.props as Props;

const id = `autocomplete-${Math.random().toString(36).slice(2, 10)}`;
const encodedOptions = encodeURIComponent(JSON.stringify(options));
const maxVisibleAttr = String(maxVisibleOptions);
const statusId = `${id}-status`;
const describedBy = statusId;
const encodedEmpty = encodeURIComponent(emptyStateText);
---

<div
  id={id}
  class={`relative space-y-3 text-slate-900 dark:text-slate-100 ${className}`.trim()}
  data-autocomplete-root
  data-autocomplete-options={encodedOptions}
  data-autocomplete-max-visible={maxVisibleAttr}
  data-autocomplete-empty-text={encodedEmpty}
>
  {
    label && (
      <label
        for={`${id}-input`}
        class="mb-1 block text-sm font-semibold text-slate-800 dark:text-slate-200"
      >
        {label}
      </label>
    )
  }
  <div class="relative">
    <input
      id={`${id}-input`}
      name={inputName}
      type="text"
      class="peer w-full rounded-xl border border-slate-300/90 bg-white px-4 py-3 text-sm font-medium text-slate-900 placeholder-slate-500 shadow-sm transition-colors focus:border-blue-600 focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-50 motion-reduce:transition-none dark:border-slate-700 dark:bg-slate-950 dark:text-slate-100 dark:placeholder-slate-400 dark:focus-visible:ring-offset-slate-950"
      placeholder={placeholder}
      aria-label={ariaLabel}
      aria-describedby={describedBy || undefined}
      data-autocomplete-input
      autocomplete="off"
      role="combobox"
      aria-autocomplete="list"
      aria-expanded="false"
      aria-controls={`${id}-panel`}
      aria-haspopup="listbox"
      spellcheck="false"
      enterkeyhint="search"
    />
    <button
      type="button"
      class="absolute right-2.5 top-1/2 flex h-8 w-8 -translate-y-1/2 items-center justify-center rounded-full border border-transparent text-slate-500 transition hover:border-blue-500 hover:bg-blue-500/10 hover:text-blue-600 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-50 motion-reduce:transition-none dark:text-slate-300 dark:hover:bg-blue-500/20 dark:hover:text-blue-300 dark:focus-visible:ring-offset-slate-950"
      data-autocomplete-clear
      aria-label="Clear input"
      hidden
    >
      ×
    </button>
  </div>
  <div
    id={statusId}
    class="sr-only"
    aria-live="polite"
    data-autocomplete-status
  >
    {
      options.length
        ? `${options.length} options available.`
        : 'No options available.'
    }
  </div>
  <div
    class="absolute left-0 top-full z-40 mt-2 w-full translate-y-2 overflow-hidden rounded-xl border border-slate-200/75 bg-white/95 text-slate-900 shadow-xl backdrop-blur supports-backdrop-filter:bg-white/80 dark:border-slate-700/70 dark:bg-slate-950/95 dark:text-slate-100"
    data-autocomplete-panel
    hidden
    id={`${id}-panel`}
    role="listbox"
    aria-hidden="true"
  >
    <ul
      class="max-h-72 overflow-y-auto scroll-py-2 divide-y divide-slate-200/80 dark:divide-slate-700/60"
      data-autocomplete-list
    >
    </ul>
    <div
      class="p-4 text-sm font-medium text-slate-500 dark:text-slate-300"
      data-autocomplete-empty
      hidden
    >
      {emptyStateText}
    </div>
  </div>
  <input type="hidden" data-autocomplete-value />
</div>

<script is:inline data-autocomplete-root={id}>
  (function setupAutocomplete() {
    const script = document.currentScript;
    const rootId = script?.getAttribute('data-autocomplete-root');
    const previous =
      script instanceof HTMLElement ? script.previousElementSibling : null;
    const fallbackRoot =
      previous instanceof HTMLElement
        ? previous.closest('[data-autocomplete-root]')
        : null;
    const root = rootId ? document.getElementById(rootId) : fallbackRoot;
    if (!(root instanceof HTMLElement)) return;
    const emptyStateMessage = root.dataset.autocompleteEmptyText
      ? decodeURIComponent(root.dataset.autocompleteEmptyText)
      : 'No results found.';

    const input = root.querySelector('[data-autocomplete-input]');
    const panel = root.querySelector('[data-autocomplete-panel]');
    const list = root.querySelector('[data-autocomplete-list]');
    const empty = root.querySelector('[data-autocomplete-empty]');
    const hidden = root.querySelector('[data-autocomplete-value]');
    const clearButton = root.querySelector('[data-autocomplete-clear]');
    const status = root.querySelector('[data-autocomplete-status]');

    if (
      !(input instanceof HTMLInputElement) ||
      !(panel instanceof HTMLElement) ||
      !(list instanceof HTMLElement) ||
      !(hidden instanceof HTMLInputElement)
    )
      return;

    const serializedOptions = root.dataset.autocompleteOptions;
    let optionsData = [];
    try {
      optionsData = serializedOptions
        ? JSON.parse(decodeURIComponent(serializedOptions))
        : [];
    } catch {
      optionsData = [];
    }
    const parsedMaxVisible = Number(root.dataset.autocompleteMaxVisible);
    const maxVisible =
      Number.isFinite(parsedMaxVisible) && parsedMaxVisible > 0
        ? parsedMaxVisible
        : 8;
    const optionIdPrefix = root.id || 'autocomplete';
    let currentQuery = '';

    const escapeHTML = (value) =>
      value.replace(/[&<>"']/g, (char) => {
        switch (char) {
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '"':
            return '&quot;';
          case "'":
            return '&#39;';
          default:
            return char;
        }
      });

    const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    const highlight = (text) => {
      if (!currentQuery) return escapeHTML(text);
      const pattern = new RegExp(escapeRegex(currentQuery), 'i');
      if (!pattern.test(text)) {
        return escapeHTML(text);
      }
      const globalPattern = new RegExp(escapeRegex(currentQuery), 'gi');
      return text
        .replace(globalPattern, (match) => `\0${match}\0`)
        .split('\0')
        .map((segment, index) => {
          if (segment === '') return '';
          if (index % 2 === 1) {
            return `<span class="rounded bg-blue-500/20 px-1 text-blue-700 dark:bg-blue-400/20 dark:text-blue-100">${escapeHTML(segment)}</span>`;
          }
          return escapeHTML(segment);
        })
        .join('');
    };

    const updateClearButton = () => {
      if (!(clearButton instanceof HTMLElement)) return;
      clearButton.hidden = input.value.length === 0;
    };

    const announce = (message) => {
      if (status instanceof HTMLElement) {
        status.textContent = message;
      }
    };

    let filtered = optionsData.slice();
    let activeIndex = -1;

    const focusOption = (index) => {
      const items = Array.from(
        list.querySelectorAll('[data-autocomplete-option]')
      );
      items.forEach((item, itemIndex) => {
        const isActive = itemIndex === index;
        item.dataset.active = isActive ? 'true' : 'false';
        item.setAttribute('aria-selected', String(isActive));
        item.setAttribute('tabindex', isActive ? '0' : '-1');
        if (isActive) {
          input.setAttribute('aria-activedescendant', item.id);
        }
      });
      activeIndex = index;
      if (index === -1) {
        input.removeAttribute('aria-activedescendant');
      }
    };

    const closePanel = () => {
      panel.hidden = true;
      input.setAttribute('aria-expanded', 'false');
      panel.setAttribute('aria-hidden', 'true');
      activeIndex = -1;
      input.removeAttribute('aria-activedescendant');
    };

    const openPanel = () => {
      panel.hidden = false;
      input.setAttribute('aria-expanded', 'true');
      panel.setAttribute('aria-hidden', 'false');
    };

    const selectOption = (index) => {
      const option = filtered[index];
      if (!option) return;
      input.value = option.label;
      hidden.value = option.value;
      updateClearButton();
      announce(`${option.label} selected.`);
      root.dispatchEvent(
        new CustomEvent('autocomplete:select', {
          bubbles: true,
          detail: option,
        })
      );
      closePanel();
    };

    const render = () => {
      if (filtered.length === 0) {
        list.innerHTML = '';
        announce(emptyStateMessage);
        if (empty) {
          empty.hidden = false;
          openPanel();
        } else {
          closePanel();
        }
        return;
      }

      if (empty) {
        empty.hidden = true;
      }
      announce(
        filtered.length === 1
          ? '1 option available.'
          : `${filtered.length} options available.`
      );
      list.innerHTML = filtered
        .slice(0, maxVisible)
        .map(
          (option, index) => `
            <li
              id="${optionIdPrefix}-option-${index}"
              class="group cursor-pointer px-4 py-3 text-sm leading-5 text-slate-800 transition-colors hover:bg-blue-600/10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-50 dark:text-slate-100 dark:hover:bg-blue-500/20 dark:focus-visible:ring-offset-slate-950 data-[active='true']:bg-blue-600/15 dark:data-[active='true']:bg-blue-500/30"
              data-autocomplete-option="${escapeHTML(option.value)}"
              role="option"
              tabindex="-1"
            >
              <div class="min-w-0 space-y-1">
                <div class="truncate font-semibold text-slate-900 dark:text-slate-50">
                  ${highlight(option.label)}
                </div>
                ${
                  option.description
                    ? `<div class="truncate text-xs text-slate-600 dark:text-slate-300">${highlight(option.description)}</div>`
                    : ''
                }
              </div>
            </li>
          `
        )
        .join('');
      focusOption(-1);
    };

    const filterOptions = (value) => {
      const query = value.trim().toLowerCase();
      currentQuery = query;
      if (!query) {
        filtered = optionsData.slice();
        render();
        closePanel();
        hidden.value = '';
        root.dispatchEvent(
          new CustomEvent('autocomplete:clear', { bubbles: true })
        );
        resetToDefaultAnnouncement();
        return;
      }

      filtered = optionsData.filter((option) => {
        const haystack = [
          option.label,
          option.value,
          option.description ?? '',
          ...(option.keywords ?? []),
        ]
          .join(' ')
          .toLowerCase();
        return haystack.includes(query);
      });

      render();
      openPanel();
      focusOption(-1);
    };

    const resetToDefaultAnnouncement = () => {
      announce(
        optionsData.length
          ? `${optionsData.length} options available.`
          : 'No options available.'
      );
    };

    input.addEventListener('input', (event) => {
      const target =
        event.target instanceof HTMLInputElement ? event.target : input;
      filterOptions(target.value);
      updateClearButton();
    });

    input.addEventListener('focus', () => {
      if (filtered.length > 0) {
        openPanel();
      }
    });

    input.addEventListener('keydown', (event) => {
      if (panel.hidden) return;

      const items = Array.from(
        list.querySelectorAll('[data-autocomplete-option]')
      );
      if (items.length === 0) return;

      if (event.key === 'ArrowDown') {
        event.preventDefault();
        const nextIndex = (activeIndex + 1) % items.length;
        focusOption(nextIndex);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        const prevIndex = (activeIndex - 1 + items.length) % items.length;
        focusOption(prevIndex);
      } else if (event.key === 'Enter') {
        event.preventDefault();
        if (activeIndex >= 0) {
          selectOption(activeIndex);
        }
      } else if (event.key === 'Escape') {
        closePanel();
      }
    });

    list.addEventListener('mousemove', (event) => {
      const target =
        event.target instanceof HTMLElement
          ? event.target.closest('[data-autocomplete-option]')
          : null;
      if (!(target instanceof HTMLElement)) return;
      const items = Array.from(
        list.querySelectorAll('[data-autocomplete-option]')
      );
      const index = items.indexOf(target);
      focusOption(index);
    });

    list.addEventListener('click', (event) => {
      const target =
        event.target instanceof HTMLElement
          ? event.target.closest('[data-autocomplete-option]')
          : null;
      if (!(target instanceof HTMLElement)) return;
      const items = Array.from(
        list.querySelectorAll('[data-autocomplete-option]')
      );
      const index = items.indexOf(target);
      selectOption(index);
      input.focus();
    });

    if (clearButton instanceof HTMLElement) {
      clearButton.addEventListener('click', () => {
        input.value = '';
        hidden.value = '';
        filtered = optionsData.slice();
        render();
        closePanel();
        input.focus();
        root.dispatchEvent(
          new CustomEvent('autocomplete:clear', { bubbles: true })
        );
        input.removeAttribute('aria-activedescendant');
        currentQuery = '';
        updateClearButton();
        resetToDefaultAnnouncement();
      });
    }

    document.addEventListener('click', (event) => {
      if (event.target instanceof Node && root.contains(event.target)) return;
      closePanel();
    });

    filtered = optionsData.slice();
    render();
    panel.setAttribute('aria-hidden', panel.hidden ? 'true' : 'false');
    updateClearButton();
    resetToDefaultAnnouncement();
  })();
</script>
