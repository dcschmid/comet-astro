---
/**
 * Signature - Touch/mouse signature pad
 *
 * Features:
 * - Touch and mouse support
 * - Customizable stroke width/color
 * - Clear and undo functionality
 * - Export as PNG/base64
 * - Responsive canvas
 *
 * @example
 * <Signature
 *   width={400}
 *   height={200}
 *   strokeColor="#1e40af"
 *   onSign={(data) => console.log(data)}
 * />
 */
import { cn } from '../utils/cn';

interface Props {
  /** Canvas width */
  width?: number;
  /** Canvas height */
  height?: number;
  /** Stroke color */
  strokeColor?: string;
  /** Stroke width */
  strokeWidth?: number;
  /** Background color */
  backgroundColor?: string;
  /** Show clear button */
  showClear?: boolean;
  /** Show undo button */
  showUndo?: boolean;
  /** Placeholder text */
  placeholder?: string;
  /** Border style */
  bordered?: boolean;
  /** Additional CSS classes */
  className?: string;
}

const {
  width = 400,
  height = 200,
  strokeColor = '#3b82f6',
  strokeWidth = 2,
  backgroundColor = 'transparent',
  showClear = true,
  showUndo = true,
  placeholder = 'Sign here',
  bordered = true,
  className = '',
} = Astro.props;

const id = `signature-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={id}
  class={cn('signature-pad inline-block', className)}
  data-signature
  data-stroke-color={strokeColor}
  data-stroke-width={strokeWidth}
  data-background-color={backgroundColor}
>
  <div
    class={cn(
      'relative rounded-lg overflow-hidden',
      bordered && 'border-2 border-dashed border-slate-600'
    )}
  >
    <canvas
      width={width}
      height={height}
      class="touch-none cursor-crosshair"
      data-signature-canvas
      style={`background-color: ${backgroundColor};`}></canvas>

    {/* Placeholder */}
    <div
      class="absolute inset-0 flex items-center justify-center pointer-events-none text-slate-500"
      data-signature-placeholder
    >
      {placeholder}
    </div>
  </div>

  {/* Controls */}
  {
    (showClear || showUndo) && (
      <div class="flex gap-2 mt-2">
        {showUndo && (
          <button
            type="button"
            class="px-3 py-1.5 text-sm bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-md transition-colors flex items-center gap-1.5"
            data-signature-undo
            disabled
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"
              />
            </svg>
            Undo
          </button>
        )}
        {showClear && (
          <button
            type="button"
            class="px-3 py-1.5 text-sm bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-md transition-colors flex items-center gap-1.5"
            data-signature-clear
            disabled
          >
            <svg
              class="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
              />
            </svg>
            Clear
          </button>
        )}
      </div>
    )
  }
</div>

<script is:inline>
  (function () {
    class SignaturePad {
      constructor(container) {
        this.container = container;
        this.canvas = container.querySelector('[data-signature-canvas]');
        this.ctx = this.canvas.getContext('2d');
        this.placeholder = container.querySelector(
          '[data-signature-placeholder]'
        );
        this.undoBtn = container.querySelector('[data-signature-undo]');
        this.clearBtn = container.querySelector('[data-signature-clear]');

        this.strokeColor = container.dataset.strokeColor || '#3b82f6';
        this.strokeWidth = parseInt(container.dataset.strokeWidth) || 2;
        this.backgroundColor =
          container.dataset.backgroundColor || 'transparent';

        this.isDrawing = false;
        this.lastX = 0;
        this.lastY = 0;
        this.history = [];
        this.isEmpty = true;

        this.init();
      }

      init() {
        // Set up canvas context
        this.ctx.strokeStyle = this.strokeColor;
        this.ctx.lineWidth = this.strokeWidth;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseout', () => this.stopDrawing());

        // Touch events
        this.canvas.addEventListener(
          'touchstart',
          (e) => this.startDrawing(e),
          { passive: false }
        );
        this.canvas.addEventListener('touchmove', (e) => this.draw(e), {
          passive: false,
        });
        this.canvas.addEventListener('touchend', () => this.stopDrawing());

        // Buttons
        this.undoBtn?.addEventListener('click', () => this.undo());
        this.clearBtn?.addEventListener('click', () => this.clear());

        this.updateButtons();
      }

      getPosition(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        if (e.touches && e.touches.length > 0) {
          return {
            x: (e.touches[0].clientX - rect.left) * scaleX,
            y: (e.touches[0].clientY - rect.top) * scaleY,
          };
        }

        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY,
        };
      }

      startDrawing(e) {
        e.preventDefault();
        this.isDrawing = true;
        const pos = this.getPosition(e);
        this.lastX = pos.x;
        this.lastY = pos.y;

        // Save state for undo
        this.saveState();
      }

      draw(e) {
        if (!this.isDrawing) return;
        e.preventDefault();

        const pos = this.getPosition(e);

        this.ctx.beginPath();
        this.ctx.moveTo(this.lastX, this.lastY);
        this.ctx.lineTo(pos.x, pos.y);
        this.ctx.stroke();

        this.lastX = pos.x;
        this.lastY = pos.y;
        this.isEmpty = false;

        this.hidePlaceholder();
      }

      stopDrawing() {
        if (this.isDrawing) {
          this.isDrawing = false;
          this.updateButtons();
          this.dispatchEvent('sign');
        }
      }

      saveState() {
        this.history.push(this.canvas.toDataURL());
        // Limit history size
        if (this.history.length > 20) {
          this.history.shift();
        }
      }

      undo() {
        if (this.history.length > 0) {
          const img = new Image();
          img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            this.updateButtons();
          };

          this.history.pop(); // Remove current state
          if (this.history.length > 0) {
            img.src = this.history[this.history.length - 1];
          } else {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.isEmpty = true;
            this.showPlaceholder();
          }

          this.dispatchEvent('undo');
        }
      }

      clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.history = [];
        this.isEmpty = true;
        this.showPlaceholder();
        this.updateButtons();
        this.dispatchEvent('clear');
      }

      hidePlaceholder() {
        if (this.placeholder) {
          this.placeholder.style.display = 'none';
        }
      }

      showPlaceholder() {
        if (this.placeholder) {
          this.placeholder.style.display = 'flex';
        }
      }

      updateButtons() {
        // const hasContent = !this.isEmpty || this.history.length > 0;
        if (this.undoBtn) this.undoBtn.disabled = this.history.length === 0;
        if (this.clearBtn)
          this.clearBtn.disabled = this.isEmpty && this.history.length === 0;
      }

      dispatchEvent(name) {
        this.container.dispatchEvent(
          new CustomEvent(`signature:${name}`, {
            bubbles: true,
            detail: {
              isEmpty: this.isEmpty,
              dataUrl: this.toDataURL(),
            },
          })
        );
      }

      toDataURL(type = 'image/png') {
        return this.canvas.toDataURL(type);
      }

      toBlob(callback, type = 'image/png') {
        this.canvas.toBlob(callback, type);
      }
    }

    // Initialize all signature pads
    document.querySelectorAll('[data-signature]').forEach((el) => {
      const pad = new SignaturePad(el);
      el._signature = pad;
    });

    // Global API
    window.SignaturePad = {
      getData(id) {
        const el = document.querySelector(id || '[data-signature]');
        return el?._signature?.toDataURL();
      },
      clear(id) {
        const el = document.querySelector(id || '[data-signature]');
        el?._signature?.clear();
      },
      isEmpty(id) {
        const el = document.querySelector(id || '[data-signature]');
        return el?._signature?.isEmpty ?? true;
      },
    };
  })();
</script>

<style>
  .signature-pad {
    /* Smooth canvas rendering */
    image-rendering: smooth;
  }

  .signature-pad canvas {
    max-width: 100%;
    height: auto;
  }

  .signature-pad button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  /* High contrast */
  @media (prefers-contrast: high) {
    .signature-pad canvas {
      border-width: 2px;
      border-style: solid;
    }
  }
</style>
