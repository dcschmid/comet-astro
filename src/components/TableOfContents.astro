---
/**
 * Generic Table of Contents component
 */
interface TocItem {
  id: string;
  label: string;
  level?: 1 | 2 | 3 | 4;
}

interface Props {
  title?: string;
  items: TocItem[];
  activeId?: string;
  className?: string;
}

const {
  title = 'Contents',
  items = [],
  activeId,
  className = '',
} = Astro.props as Props;
---

<nav
  aria-label="Table of contents"
  class={`rounded-xl border border-slate-200 bg-white p-4 text-slate-900 shadow-sm dark:border-slate-800 dark:bg-slate-950 dark:text-slate-100 ${className}`.trim()}
>
  <div
    class="mb-2 text-sm font-semibold uppercase tracking-wide text-slate-700 dark:text-slate-200"
  >
    {title}
  </div>
  <ul class="space-y-1">
    {
      items.map((item) => (
        <li class="block text-slate-700 dark:text-slate-200">
          <a
            href={`#${item.id}`}
            class:list={[
              'block rounded-md px-2 py-1 no-underline transition hover:bg-blue-50 hover:text-blue-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-600 focus-visible:ring-offset-2 focus-visible:ring-offset-white dark:hover:bg-slate-800 dark:hover:text-blue-300 dark:focus-visible:ring-offset-slate-900',
              item.level === 2 && 'pl-4',
              item.level === 3 && 'pl-6',
              item.level === 4 && 'pl-8',
              activeId === item.id &&
                'text-blue-700 dark:text-blue-300 font-semibold',
            ]}
          >
            {item.label}
          </a>
        </li>
      ))
    }
  </ul>
</nav>

<script is:inline>
  // Optional: auto-highlight based on visible heading ids
  (function () {
    const ACTIVE_CLASS = 'text-blue-700 dark:text-blue-300 font-semibold';
    const nav = document.currentScript?.previousElementSibling;
    if (!(nav instanceof HTMLElement)) return;
    const links = Array.from(nav.querySelectorAll('a'));
    if (!links.length) return;

    const map = new Map();
    links.forEach((a) => {
      const id = a.getAttribute('href')?.slice(1);
      if (id) map.set(id, a);
    });

    const observer = new IntersectionObserver(
      (entries) => {
        let topMost: IntersectionObserverEntry | undefined;
        for (const e of entries) {
          if (e.isIntersecting) {
            if (
              !topMost ||
              e.boundingClientRect.top < topMost.boundingClientRect.top
            ) {
              topMost = e;
            }
          }
        }
        if (topMost) {
          const id = topMost.target.id;
          links.forEach((a) => a.classList.remove(...ACTIVE_CLASS.split(' ')));
          const target = map.get(id);
          if (target instanceof HTMLElement) {
            target.classList.add(...ACTIVE_CLASS.split(' '));
          }
        }
      },
      { rootMargin: '0px 0px -70% 0px', threshold: [0, 1] }
    );

    map.forEach((_a, id) => {
      const el = document.getElementById(id);
      if (el) observer.observe(el);
    });
  })();
</script>
