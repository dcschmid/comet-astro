---
/**
 * FullscreenOverlay - WCAG AAA compliant fullscreen overlay for dialogs, modals, and confirmations
 * Enhanced with proper focus management, keyboard navigation, and semantic HTML
 */
interface Props {
  /** Whether the overlay is open */
  open?: boolean;
  /** Title for the overlay - important for accessibility */
  title?: string;
  /** Whether the overlay can be closed by user interaction */
  closable?: boolean;
  /** Accessible label for the close button */
  closeLabel?: string;
  /** Additional CSS classes */
  className?: string;
  /** Size variant for the overlay content */
  size?: 'sm' | 'md' | 'lg' | 'xl';
  /** Whether to prevent closing on backdrop click */
  preventBackdropClose?: boolean;
  /** Whether to prevent closing on escape key */
  preventEscapeClose?: boolean;
  /** Custom aria-label for the dialog */
  ariaLabel?: string;
  /** ID for aria-describedby */
  ariaDescribedby?: string;
}

const {
  open = false,
  title,
  closable = true,
  closeLabel = 'Close',
  className = '',
  size = 'md',
  preventBackdropClose = false,
  preventEscapeClose = false,
  ariaLabel,
  ariaDescribedby,
} = Astro.props as Props;

// Enhanced size variants with responsive design
const sizeClasses = {
  sm: 'w-[min(90vw,400px)]',
  md: 'w-[min(92vw,600px)]',
  lg: 'w-[min(94vw,800px)]',
  xl: 'w-[min(96vw,1000px)]',
};

const overlayId = 'comet-fullscreen-overlay';
const titleId = title ? 'comet-overlay-title' : undefined;
---

<div
  id={overlayId}
  class={`fixed inset-0 z-50 flex items-center justify-center p-4 ${open ? '' : 'hidden'}`}
  role="dialog"
  aria-modal="true"
  aria-labelledby={titleId}
  aria-label={ariaLabel}
  aria-describedby={ariaDescribedby}
>
  <!-- Enhanced backdrop with WCAG AAA contrast -->
  <div
    class="absolute inset-0 bg-slate-950/80 backdrop-blur-sm transition-opacity duration-200"
    data-overlay-backdrop={!preventBackdropClose ? '' : undefined}
    aria-hidden="true"
  >
  </div>

  <!-- Main dialog content with enhanced styling and accessibility -->
  <div
    class={`
      relative mx-auto ${sizeClasses[size]} max-w-full rounded-2xl 
      border-2 border-slate-200/20 bg-white/95 backdrop-blur-md
      shadow-2xl ring-1 ring-slate-900/5
      dark:border-slate-700/30 dark:bg-slate-900/95 dark:ring-slate-100/5
      ${className}
    `.trim()}
    role="document"
  >
    <!-- Enhanced header with better contrast and spacing -->
    <header
      class="flex items-start justify-between gap-4 border-b border-slate-200/50 p-6 dark:border-slate-700/50"
    >
      {
        title && (
          <h2
            id={titleId}
            class="text-xl font-semibold leading-tight text-slate-900 dark:text-slate-50"
          >
            {title}
          </h2>
        )
      }
      {
        closable && (
          <button
            type="button"
            class={`
              inline-flex items-center justify-center rounded-lg border-2
              border-slate-300 bg-white px-4 py-2 text-sm font-semibold
              text-slate-800 shadow-sm transition-all duration-150
              hover:border-slate-400 hover:bg-slate-50 hover:shadow-md
              focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-offset-2
              active:bg-slate-100 active:scale-95
              dark:border-slate-600 dark:bg-slate-800 dark:text-slate-200
              dark:hover:border-slate-500 dark:hover:bg-slate-700
              dark:focus:ring-blue-400 dark:focus:ring-offset-slate-900
              dark:active:bg-slate-600
            `.trim()}
            data-overlay-close
            aria-label={`${closeLabel} dialog`}
          >
            <svg
              class="mr-2 h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
            {closeLabel}
          </button>
        )
      }
    </header>

    <!-- Content area with enhanced scrolling and readability -->
    <div
      class={`
        max-h-[calc(80vh-8rem)] overflow-auto p-6 text-base leading-relaxed
        text-slate-700 scrollbar-thin scrollbar-track-slate-100 scrollbar-thumb-slate-300
        dark:text-slate-200 dark:scrollbar-track-slate-800 dark:scrollbar-thumb-slate-600
      `.trim()}
    >
      <slot />
    </div>

    <!-- Enhanced actions footer -->
    <div class="border-t border-slate-200/50 p-6 dark:border-slate-700/50">
      <div class="flex flex-wrap items-center justify-end gap-3">
        <slot name="actions" />
      </div>
    </div>
  </div>
</div>

<script
  is:inline
  define:vars={{ overlayId, preventBackdropClose, preventEscapeClose }}
>
  (function () {
    const root = document.getElementById(overlayId);
    if (!(root instanceof HTMLElement)) return;

    const backdrop = root.querySelector('[data-overlay-backdrop]');
    const closeBtn = root.querySelector('[data-overlay-close]');
    const panel = root.querySelector('[role="dialog"]') || root;
    let lastFocused = null;
    let isOpen = false;

    // Enhanced focusable element detection
    const getFocusable = () => {
      const selectors = [
        'a[href]:not([tabindex="-1"])',
        'button:not([disabled]):not([tabindex="-1"])',
        'textarea:not([disabled]):not([tabindex="-1"])',
        'input:not([disabled]):not([tabindex="-1"])',
        'select:not([disabled]):not([tabindex="-1"])',
        '[tabindex]:not([tabindex="-1"])',
        '[contenteditable="true"]',
      ].join(', ');

      return Array.from(root.querySelectorAll(selectors)).filter((el) => {
        if (!(el instanceof HTMLElement)) return false;
        if (el.tabIndex < 0) return false;

        // Check if element is visible and not hidden
        const style = window.getComputedStyle(el);
        return (
          style.display !== 'none' &&
          style.visibility !== 'hidden' &&
          el.offsetParent !== null
        );
      });
    };

    // Enhanced open function with better focus management
    const open = () => {
      if (isOpen || !root.classList.contains('hidden')) return;

      // Store current focus
      lastFocused =
        document.activeElement instanceof HTMLElement
          ? document.activeElement
          : null;

      // Show overlay
      root.classList.remove('hidden');
      isOpen = true;

      // Prevent body scroll with enhanced support
      document.body.style.setProperty('overflow', 'hidden');
      document.documentElement.style.setProperty('overflow', 'hidden');

      // Set focus to first focusable element or close button
      requestAnimationFrame(() => {
        const focusable = getFocusable();
        const firstFocusable = focusable[0];
        const preferredFocus = closeBtn || firstFocusable || panel;

        if (preferredFocus) {
          preferredFocus.focus({ preventScroll: true });
        }
      });

      // Announce to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'assertive');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = 'Dialog opened';
      document.body.appendChild(announcement);

      setTimeout(() => {
        document.body.removeChild(announcement);
      }, 1000);
    };

    // Enhanced close function
    const close = () => {
      if (!isOpen || root.classList.contains('hidden')) return;

      root.classList.add('hidden');
      isOpen = false;

      // Restore body scroll
      document.body.style.removeProperty('overflow');
      document.documentElement.style.removeProperty('overflow');

      // Restore focus with delay for better UX
      if (lastFocused) {
        requestAnimationFrame(() => {
          if (lastFocused && document.contains(lastFocused)) {
            lastFocused.focus({ preventScroll: true });
          }
        });
      }

      // Announce to screen readers
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'assertive');
      announcement.setAttribute('aria-atomic', 'true');
      announcement.className = 'sr-only';
      announcement.textContent = 'Dialog closed';
      document.body.appendChild(announcement);

      setTimeout(() => {
        if (document.body.contains(announcement)) {
          document.body.removeChild(announcement);
        }
      }, 1000);
    };

    // Enhanced event listeners
    if (closeBtn) {
      closeBtn.addEventListener('click', close);
    }

    if (backdrop && !preventBackdropClose) {
      backdrop.addEventListener('click', close);
    }

    // Enhanced keyboard handling
    const handleKeydown = (event) => {
      if (!isOpen) return;

      if (event.key === 'Escape' && !preventEscapeClose) {
        event.preventDefault();
        close();
        return;
      }

      if (event.key === 'Tab') {
        const focusable = getFocusable();
        if (!focusable.length) {
          event.preventDefault();
          return;
        }

        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        const activeElement = document.activeElement;

        if (event.shiftKey) {
          // Shift + Tab: move to previous element
          if (activeElement === first) {
            event.preventDefault();
            last.focus({ preventScroll: true });
          }
        } else {
          // Tab: move to next element
          if (activeElement === last) {
            event.preventDefault();
            first.focus({ preventScroll: true });
          }
        }
      }
    };

    document.addEventListener('keydown', handleKeydown);

    // Cleanup function for better memory management
    const cleanup = () => {
      document.removeEventListener('keydown', handleKeydown);
      if (closeBtn) closeBtn.removeEventListener('click', close);
      if (backdrop) backdrop.removeEventListener('click', close);
    };

    // Enhanced global API
    window.CometOverlay = {
      open,
      close,
      isOpen: () => isOpen,
      cleanup,
    };

    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
  })();
</script>
